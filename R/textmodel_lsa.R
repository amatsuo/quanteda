#' @rdname textmodel-internal
#' @keywords internal textmodel
#' @export
setClass("textmodel_lsa_fitted",
         slots = c(nd = "numeric"),
         contains = "textmodel_fitted")

#' Latent Semantic Analysis
#' 
#' Fit the Latent Semantic Analysis scaling model to a \link{dfm}, which may be
#' weighted (for instance using \code{\link{tfidf}}).
#' @param x the \link{dfm} on which the model will be fit
#' @param nd  the number of dimensions to be included in output
#' @author Haiyan Wang
#' @details \link[RSpectra]{svds} in the \pkg{RSpectra} package is applied to 
#'   enable the fast computation of the SVD.
#' @note  The number of dimensions \code{nd} retained in LSA is an empirical
#'   issue. While a reduction in \deqn{k} can remove much of the noise, keeping
#'   too few dimensions or factors may loose important information.
#' @references 
#'   Rosario, Barbara.  2000.
#'   "\href{http://www.sims.berkeley.edu/rosario/projects/LSI.pdf}{Latent 
#'   Semantic Indexing: An overview}". \emph{Technical report INFOSYS 240 Spring
#'   Paper, University of California, Berkeley.}
#'   
#'   Deerwester, S., Dumais, S. T., Furnas, G. W., Landauer, T. K., & Harshman, 
#'   R. 1990. 
#'   "\href{http://search.proquest.com/openview/a1907164bd88dfc38a4875b73a3f7b3d/1?pq-origsite=gscholar&cbl=1818555}{Indexing
#'   by latent semantic analysis}". \emph{Journal of the American society for 
#'   information science} 41(6), 391.
#' @examples 
#' ieDfm <- dfm(data_corpus_irishbudget2010)
#' # create an LSA space and return its truncated representation in the low-rank space
#' mylsa <- textmodel_lsa(ieDfm[1:10, ])
#' head(mylsa$docs)
#' 
#' #matrix in low_rank LSA space
#' mylsa$matrix_low_rank[,1:5]
#' 
#' # fold queries into the space generated by ieDfm[1:10,]
#' # and return its truncated versions of its representation in the new low-rank space
#' newlsa <- transform_lsa(ieDfm[11:14, ], mylsa)
#' newlsa$transDocs
#' @export
textmodel_lsa <- function(x, nd = 10) {
    UseMethod("textmodel_lsa")
}

#' @rdname textmodel_lsa
#' @export
textmodel_lsa.dfm <- function(x, nd = 10) {

    if (nd > min(nrow(x), ncol(x))) nd <- min(nrow(x), ncol(x))
    if (nd < 2) nd <- 2
    #dec <- rsvd::rsvd(S, nd)   #rsvd is not as stable as RSpectra
    #dec <- irlba::irlba(S, nd)
    dec <- RSpectra::svds(x, nd)   
    
    if (any(dec$d <= sqrt(.Machine$double.eps))) {
        warning("[lsa] - there are singular values which are zero.");
    }
    
    space <- NULL
    space$dk <- dec$u
    space$tk <- dec$v
    space$sk <- dec$d
    space$docs <- dec$u
    space$features <- dec$v
    rownames(space$dk) <- rownames(x)
    rownames(space$tk) <- colnames(x)
    rownames(space$docs) <- rownames(x)
    rownames(space$features) <- colnames(x)
    
    #low_rank matrix
    space$matrix_low_rank <- dec$u %*% diag(dec$d) %*% t(dec$v)
    rownames(space$matrix_low_rank) <- rownames(x)
    colnames(space$matrix_low_rank) <- colnames(x)
    # to be compatible with "lsa" package
    class(space) = c("textmodel_lsa_fitted", "LSAspace")
    
    # return the LSA space
    return ( space )
}

#' @rdname textmodel_lsa
#' @param newX new matrix to be transformed into the lsa space
#' @param LSAspace previously fitted lsa space
#' @export
transform_lsa <- function( newX, LSAspace ) {
    tsa =  newX %*% LSAspace$tk %*% solve(diag(LSAspace$sk))
    transfed =  t( LSAspace$tk %*% diag(LSAspace$sk) %*% t(tsa) ) 
    
    colnames(transfed) <- rownames(LSAspace$tk)
    rownames(transfed) <- rownames(newX)
    
    newSpace <- NULL
    newSpace$transDocs <- tsa
    rownames(newSpace$transDocs) <- rownames(newX)
    
    newSpace$matrix_low_rank <- transfed
    return (newSpace)
}
