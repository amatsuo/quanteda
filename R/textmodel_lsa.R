#' @rdname textmodel-internal
#' @keywords internal textmodel
#' @export
setClass("textmodel_lsa_fitted",
         slots = c(x = "dfm", nd = "numeric"),
         contains = "textmodel_fitted")

#' @rdname textmodel-internal
#' @keywords internal textmodel
#' @export
setClass("textmodel_lsa_predicted",
         slots = c(newdata = "dfm"),
         contains = "textmodel_lsa_fitted")
#' Latent Semantic Analysis
#' 
#' Fit the Latent Semantic Analysis scaling model to a \link{dfm}, which may be
#' weighted (for instance using \code{\link{tfidf}}).
#' @param x the \link{dfm} on which the model will be fit
#' @param nd  the number of dimensions to be included in output
#' @author Haiyan Wang
#' @details \link[RSpectra]{svds} in the \pkg{RSpectra} package is applied to 
#'   enable the fast computation of the SVD.
#' @note  The number of dimensions \code{nd} retained in LSA is an empirical
#'   issue. While a reduction in \eqn{k} can remove much of the noise, keeping
#'   too few dimensions or factors may lose important information.
#' @references 
#'   Rosario, Barbara.  2000.
#'   "\href{http://www.cse.msu.edu/~cse960/Papers/LSI/LSI.pdf}{Latent 
#'   Semantic Indexing: An overview}". \emph{Technical report INFOSYS 240 Spring
#'   Paper, University of California, Berkeley.}
#'   
#'   Deerwester, S., Dumais, S. T., Furnas, G. W., Landauer, T. K., & Harshman, 
#'   R. 1990. 
#'   "\href{http://search.proquest.com/openview/a1907164bd88dfc38a4875b73a3f7b3d/1?pq-origsite=gscholar&cbl=1818555}{Indexing
#'   by latent semantic analysis}". \emph{Journal of the American society for 
#'   information science} 41(6), 391.
#' @examples 
#' ieDfm <- dfm(data_corpus_irishbudget2010)
#' # create an LSA space and return its truncated representation in the low-rank space
#' mylsa <- textmodel_lsa(ieDfm[1:10, ])
#' head(mylsa$docs)
#' #matrix in low_rank LSA space
#' mylsa$matrix_low_rank[,1:5]
#' # fold queries into the space generated by ieDfm[1:10,]
#' # and return its truncated versions of its representation in the new low-rank space
#' newlsa <- predict(mylsa, ieDfm[11:14, ])
#' newlsa$transDocs
#' @export
textmodel_lsa <- function(x, nd = 10) {
    UseMethod("textmodel_lsa")
}

#' @noRd
#' @export
textmodel_lsa.dfm <- function(x, nd = 10) {

    if (nd > min(nrow(x), ncol(x))) nd <- min(nrow(x), ncol(x))
    if (nd < 2) nd <- 2
    #dec <- rsvd::rsvd(S, nd)   #rsvd is not as stable as RSpectra
    #dec <- irlba::irlba(S, nd)
    dec <- RSpectra::svds(x, nd)   
    
    if (any(dec$d <= sqrt(.Machine$double.eps))) {
        warning("[lsa] - there are singular values which are zero.");
    }
    
    space <- NULL
    space$sk <- dec$d
    space$docs <- dec$u
    space$features <- dec$v
    rownames(space$docs) <- rownames(x)
    rownames(space$features) <- colnames(x)
    
    #low_rank matrix
    space$matrix_low_rank <- dec$u %*% diag(dec$d) %*% t(dec$v)
    rownames(space$matrix_low_rank) <- rownames(x)
    colnames(space$matrix_low_rank) <- colnames(x)
    
    #keep the input matrix
    space$data <- x
    
    class(space) = c("textmodel_lsa_fitted")
    
    # return the LSA space
    return ( space )
}

#' Transformation method for Latent Sementic Analysis objects
#'
#' @rdname textmodel_lsa
#' @param newdata new matrix to be transformed into the lsa space
#' @param object previously fitted lsa space
#' @keywords internal textmodel
#' @export
predict.textmodel_lsa_fitted <- function(object, newdata = NULL, ...) {
    
    call <- match.call()
    if (is.null(newdata)) newdata <- object$data
    
    tsa =  newdata %*% object$features %*% solve(diag(object$sk))
    transfed =  t( object$features %*% diag(object$sk) %*% t(tsa) ) 
    
    colnames(transfed) <- rownames(object$features)
    rownames(transfed) <- rownames(newdata)
    
    newSpace <- NULL
    newSpace$transDocs <- tsa
    rownames(newSpace$transDocs) <- rownames(newdata)
    
    newSpace$matrix_low_rank <- transfed
    class(newSpace) <- "textmodel_lsa_predicted"
    return (newSpace)
}

#' @rdname textmodel-internal
#' @param doc_dim,feat_dim the document and feature dimension scores to be 
#'   extracted as coefficients
#' @export
setMethod("coef", signature(object = "textmodel_lsa_fitted"),
          function(object, doc_dim = 1, feat_dim = 1,...) 
              list(coef_feature = object$features[, feat_dim],
                   coef_feature_se = rep(NA, dim(object$features)[1]),
                   coef_document = object$docs[, doc_dim],
                   coef_document_se = rep(NA, dim(object$docs)[1]))
                   
)

#' @rdname textmodel-internal
#' @export
setMethod("coefficients", signature(object = "textmodel_lsa_fitted"),
          function(object, ...) coef(object, ...))
