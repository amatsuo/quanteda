% Generated by roxygen2 (4.0.2): do not edit by hand
\name{segmentSentence}
\alias{segment}
\alias{segment.character}
\alias{segment.corpus}
\alias{segmentParagraph}
\alias{segmentSentence}
\title{segment texts into component elements}
\usage{
segmentSentence(x, delimiter = "[.!?:;]")

segmentParagraph(x, delimiter = "\\\\n{2}")

segment(x, ...)

\method{segment}{character}(x, what = c("tokens", "sentences", "paragraphs",
  "tags", "other"), delimiter = ifelse(what == "tokens", " ", ifelse(what ==
  "sentences", "[.!?:;]", ifelse(what == "paragraphs", "\\\\n{2}", ifelse(what
  == "tags", "\\\\s*##\\\\w+\\\\b\\\\s*", NULL)))), ...)

\method{segment}{corpus}(x, what = c("tokens", "sentences", "paragraphs",
  "tags", "other"), delimiter = ifelse(what == "tokens", " ", ifelse(what ==
  "sentences", "[.!?:;]", ifelse(what == "paragraphs", "\\\\n{2}", ifelse(what
  == "tags", "\\\\s*##\\\\w+\\\\b\\\\s*", NULL)))), ...)
}
\arguments{
\item{x}{text or corpus object to be segmented}

\item{delimiter}{delimiter defined as a \link{regex} for segmentation. Each
type has its own default, except \code{other}, which requires a value to be
specified.}

\item{...}{provides additional arguments to be passed to \link{clean}}

\item{what}{unit of segmentation.  Current options are tokens, sentences,
paragraphs, and other.  Segmenting on \code{other} allows segmentation of a
text on any user-defined value, and must be accompanied by the
\code{delimiter} argument.}
}
\value{
\code{segmentSentence} returns a character vector of sentences that
  have been segmented

\code{segmentParagraph} returns a character vector of paragraphs that
  have been segmented

A list of segmented texts, with each element of the list correponding
  to one of the original texts.
}
\description{
Segment text(s) into tokens, sentences, paragraphs, or other sections.
\code{segment} works on a character vector or corpus object, and allows the
delimiters to be defined.  See details.
}
\details{
Tokens are delimited by whitespace.  For sentences, the delimiter
  can be defined by the user.  The default for sentences includes \code{.},
  \code{!}, \code{?}, plus \code{;} and \code{:}.

  For paragraphs, the default is two carriage returns, although this could be
  changed to a single carriage return by changing the value of
 \code{delimiter} to \code{"\\\n{1}"} which is the R version of the
  \link{regex} for one newline character.  (You might
  need this if the document was created in a word processor, for instance,
  and the lines were wrapped in the window rather than being hard-wrapped
  with a newline character.)
}
\note{
Does not currently record document segments if segmenting a multi-text corpus
into smaller units. For this, use \link{changeunits} instead.
}
\examples{
# segment sentences of the UK 2010 immigration sections of manifestos
segmentSentence(uk2010immig[1])[1:5]   # 1st 5 sentences from first (BNP) text
str(segmentSentence(uk2010immig[1]))   # a 143-element char vector
str(segmentSentence(uk2010immig[1:2])) # a 155-element char vector (143+ 12)
# segment paragraphs
segmentParagraph(uk2010immig[3])[1:2]   # 1st 2 Paragraphs from 3rd (Con) text
str(segmentParagraph(uk2010immig[3]))   # a 12-element char vector
# same as tokenize()
identical(tokenize(uk2010immig, lower=FALSE), segment(uk2010immig, lower=FALSE))

# segment into paragraphs
segment(uk2010immig[3:4], "paragraphs")

# segment a text into sentences
segmentedChar <- segment(uk2010immig, "sentences")
segmentedChar[2]
testCorpus <- corpus("##INTRO This is the introduction.
                      ##DOC1 This is the first document.
                      Second sentence in Doc 1.
                      ##DOC3 Third document starts here.
                      End of third document.")
testCorpusSeg <- segment(testCorpus, "tags")
summary(testCorpusSeg)
texts(testCorpusSeg)
# segment a corpus into sentences
segmentedCorpus <- segment(corpus(uk2010immig), "sentences")
identical(segmentedCorpus, segmentedChar)
}

