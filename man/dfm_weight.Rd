% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dfm_weight.R
\docType{methods}
\name{dfm_weight}
\alias{dfm_smooth}
\alias{dfm_weight}
\alias{dfm_weight,dfm,character-method}
\alias{dfm_weight,dfm,numeric-method}
\title{weight the feature frequencies in a dfm}
\usage{
dfm_weight(x, type, ...)

\S4method{dfm_weight}{dfm,character}(x, type = c("frequency", "relFreq",
  "relMaxFreq", "logFreq", "tfidf"), ...)

\S4method{dfm_weight}{dfm,numeric}(x, type, ...)

dfm_smooth(x, smoothing = 1)
}
\arguments{
\item{x}{document-feature matrix created by \link{dfm}}

\item{type}{a label of the weight type, or a named numeric vector of values to apply to the dfm. One of:
\describe{
 \item{\code{"frequency"}}{integer feature count (default when a dfm is created)}
 \item{\code{"relFreq"}}{the proportion of the feature counts of total feature counts (aka relative frequency)}
 \item{\code{"relMaxFreq"}}{the proportion of the feature counts of the highest feature count in a document}
 \item{\code{"logFreq"}}{natural logarithm of the feature count}
 \item{\code{"tfidf"}}{Term-frequency * inverse document frequency. For a
  full explanation, see, for example, 
  \url{http://nlp.stanford.edu/IR-book/html/htmledition/term-frequency-and-weighting-1.html}.
   This implementation will not return negative values.  For finer-grained
  control, call \code{\link{tfidf}} directly.}
  \item{a named numeric vector}{a named numeric vector of weights to be applied to the dfm, 
  where the names of the vector correspond to feature labels of the dfm, and 
  the weights will be applied as multipliers to the existing feature counts 
  for the corresponding named fatures.  Any features not named will be 
  assigned a weight of 1.0 (meaning they will be unchanged).}
  }}

\item{...}{not currently used.}

\item{smoothing}{constant added to the dfm cells for smoothing, default is 1}
}
\value{
The dfm with weighted values.
}
\description{
Returns a document by feature matrix with the feature frequencies weighted 
according to one of several common methods.  Some shortcuts that offer finer-grained control are:
\itemize{
\item{\code{\link{tf}}}{  compute term frequency weights}
\item{\code{\link{tfidf}}}{  compute term frequency-inverse document frequency weights}
\item{\code{\link{docfreq}}}{  compute document frequencies of features}
}
}
\details{
This converts a matrix from sparse to dense format, so may exceed memory
requirements depending on the size of your input matrix.
}
\note{
For finer grained control, consider calling \code{\link{tf}} or \code{\link{tfidf}} directly.
}
\examples{
dtm <- dfm(data_corpus_inaugural)

x <- apply(dtm, 1, function(tf) tf/max(tf))
topfeatures(dtm)
normDtm <- dfm_weight(dtm, "relFreq")
topfeatures(normDtm)
maxTfDtm <- dfm_weight(dtm, type = "relMaxFreq")
topfeatures(maxTfDtm)
logTfDtm <- dfm_weight(dtm, type = "logFreq")
topfeatures(logTfDtm)
tfidfDtm <- dfm_weight(dtm, type = "tfidf")
topfeatures(tfidfDtm)

# combine these methods for more complex dfm_weightings, e.g. as in Section 6.4
# of Introduction to Information Retrieval
head(logTfDtm <- dfm_weight(dtm, type = "logFreq"))
head(tfidf(logTfDtm, normalize = FALSE))

\dontshow{
testdfm <- dfm(data_char_inaugural[1:5], verbose = FALSE)
for (w in c("frequency", "relFreq", "relMaxFreq", "logFreq", "tfidf")) {
    testw <- dfm_weight(testdfm, w)
    cat("\\n\\n=== weight() TEST for:", w, "; class:", class(testw), "\\n")
    head(testw)
}}
# apply numeric weights
str <- c("apple is better than banana", "banana banana apple much better")
weights <- c(apple = 5, banana = 3, much = 0.5)
(mydfm <- dfm(str, remove = stopwords("english")))
dfm_weight(mydfm, weights)


# smooth the dfm
dfm_smooth(mydfm, 0.5)
}
\author{
Paul Nulty and Kenneth Benoit
}
\references{
Manning, Christopher D., Prabhakar Raghavan, and Hinrich Schutze.
  \emph{Introduction to Information Retrieval}. Vol. 1. Cambridge: Cambridge 
  University Press, 2008.
}
\seealso{
\code{\link{tf}},  \code{\link{tfidf}}, \code{\link{docfreq}}
}
\keyword{weighting}

